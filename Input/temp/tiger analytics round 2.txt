//Q1
//-------
val mobilePingsDF=spark.read.option("delimiter","|").option("header","true").option("inferSchema","true").csv("file:///home/raptor/IdeaProjects/SparkLearning/Input/temp/mobilePings.txt")

val pingCountDF=mobilePingsDF.groupBy("mobile_handset_code").agg(count("ping_location").as("pingCount"))

import org.apache.spark.sql.expressions.Window

val maxSeenLocationDF=mobilePingsDF.groupBy("mobile_handset_code","ping_location").agg(count("*").as("location_hit_count")).withColumn("max_seen_location_rank",dense_rank.over(Window.partitionBy("mobile_handset_code").orderBy(desc("location_hit_count")))).filter("max_seen_location_rank=1")

pingCountDF.join(maxSeenLocationDF,Seq("mobile_handset_code")).selectExpr("mobile_handset_code","pingCount","ping_location as max_seen_location").orderBy("mobile_handset_code").show

//Q2:
//--------
// refer mage in the folder for  more depth on understanding
val programInputDF=spark.read.option("delimiter","|").option("header","true").option("inferSchema","true").csv("file:///home/raptor/IdeaProjects/SparkLearning/Input/temp/programChannelInput.txt")

//val programInputDF=spark.read.option("delimiter","|").option("header","true").option("inferSchema","true").csv("file:///home/raptor/IdeaProjects/SparkLearning/Input/temp/programChannelInput2.txt")


import org.joda.time.DateTime
import org.joda.time.format.DateTimeFormat

/*


userId|channelName|showName|startTime|endTime
A|c1|p1|10:00:02|10:16:15
A|c1|p1|10:17:02|10:17:45
A|c1|p1|10:19:20|10:19:30
A|c1|p1|10:19:40|10:19:59

A|c1|p2|10:17:46|10:18:32

B|c1|p1|10:00:02|10:04:03
B|c1|p1|10:05:02|10:05:13

B|c1|p5|11:01:02|11:12:18


+------+-----------+--------+---------+--------+
|userId|channelName|showName|startTime|endTime |
+------+-----------+--------+---------+--------+
|A     |c1         |p1      |10:00:02 |10:16:15|
|A     |c1         |p1      |10:17:02 |10:17:45|
|A     |c1         |p1      |10:19:20 |10:19:30|
|A     |c1         |p1      |10:19:40 |10:19:59|
|A     |c1         |p2      |10:17:46 |10:18:32|
|B     |c1         |p1      |10:00:02 |10:04:03|
|B     |c1         |p1      |10:05:02 |10:05:13|
|B     |c1         |p5      |11:01:02 |11:12:18|
+------+-----------+--------+---------+--------+

val dateFormat="HH:mm:ss"
val startTimeTemp=DateTime.parse("00:11:12",DateTimeFormat.forPattern(dateFormat))

startTimeTemp.getHourOfDay
startTimeTemp.getMinuteOfHour
startTimeTemp.getSecondOfMinute

finalStartDate.getHourOfDay
finalStartDate.getMinuteOfHour
finalStartDate.getSecondOfMinute

val userList=programInputDF.select("userID").distinct.orderBy("userId").collect.map(_(0).toString)
val user=userList(0)
val channelList=programInputDF.where(s"userID='${user}'").select("channelName").distinct.orderBy("userId","channelName","showName").collect.map(_(0).toString)
val channel=channelList(0)
val showList=programInputDF.where(s"userID='${user}' and channelName='${channel}'").select("showName").distinct.orderBy("userId","channelName","showName").collect.map(_(0).toString)
val show=showList(0)
val currentList=programInputDF.where(s"userID='${user}' and channelName='${channel}' and  showName='${show}'").distinct.orderBy("userId","channelName","showName","startTime").collect
val currentRowInList=0
*/
case class program(userId:String,channelName:String,showName:String,startTime:String,endTime:String)

val finalArrayBuffer:collection.mutable.ArrayBuffer[program]=collection.mutable.ArrayBuffer[program]()

for(user <- userList)
{
var tempDF:DataFrame=null
val channelList=programInputDF.where(s"userID='${user}'").select("channelName").distinct.orderBy("userId","channelName","showName").collect.map(_(0).toString)
for(channel <- channelList)
{
val showList=programInputDF.where(s"userID='${user}' and channelName='${channel}'").select("showName").distinct.orderBy("userId","channelName","showName").collect.map(_(0).toString)
for(show <- showList)
{
val currentList=programInputDF.where(s"userID='${user}' and channelName='${channel}' and  showName='${show}'").distinct.orderBy("userId","channelName","showName","startTime").collect
if(currentList.size==1)
finalArrayBuffer+=program(currentList(0)(0).toString,currentList(0)(1).toString,currentList(0)(2).toString,currentList(0)(3).toString,currentList(0)(4).toString)
else
{
//val currentRowInList=0
var finalStartDate:org.joda.time.DateTime=null
var finalEndDate:org.joda.time.DateTime=null
val currentListSize=currentList.size
for (currentRowInList <- 0 to currentListSize-1)
{
if (currentRowInList < currentListSize-1)
{
val currentRecord=currentList(currentRowInList)
//println(s"index : ${currentRowInList}")
//println(currentRecord)
val nextRecord=currentList(currentRowInList+1)
//println(nextRecord)
val currentRecordStartTime=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val currentRecordEndTime=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val nextRecordStartTime=DateTime.parse(nextRecord(3).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val nextRecordEndTime=DateTime.parse(nextRecord(4).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
nextRecordStartTime match
{
case value if (value <= currentRecordEndTime || currentRecordEndTime+1000 == value )  => currentRowInList match {
case 0 => {
if(nextRecordEndTime > currentRecordEndTime)
{
finalStartDate=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat))
finalEndDate=DateTime.parse(nextRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
}
if(nextRecordEndTime < currentRecordEndTime)
{
finalStartDate=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat))
finalEndDate=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
}
}
case _ => if(finalStartDate== null) 
{
if(nextRecordEndTime > currentRecordEndTime)
{
finalStartDate=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat))
finalEndDate=DateTime.parse(nextRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
}
if(nextRecordEndTime < currentRecordEndTime)
{
finalStartDate=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat))
finalEndDate=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
}
}
else 
{
if(nextRecordEndTime > currentRecordEndTime)
finalEndDate=DateTime.parse(nextRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
if(nextRecordEndTime < currentRecordEndTime)
finalEndDate=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
}
}
case _ => {
if(finalStartDate != null && finalStartDate != null) 
{finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,timeGenerator(finalStartDate),timeGenerator(finalEndDate));finalStartDate=null;finalEndDate=null}
else 
{finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,currentRecord(3).toString,currentRecord(4).toString)}
}
}
}
else
{
val currentRecord=currentList(currentRowInList)
//println(s"index : ${currentRowInList}")
//println(currentRecord)
val previousRecord=currentList(currentRowInList-1)
val currentRecordStartTime=DateTime.parse(currentRecord(3).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val currentRecordEndTime=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val previousRecordStartTime=DateTime.parse(previousRecord(3).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
val previousRecordEndTime=DateTime.parse(previousRecord(4).toString,DateTimeFormat.forPattern(dateFormat)).getMillisOfDay
currentRecordStartTime match
{
case value if (value <= previousRecordEndTime || previousRecordEndTime+1000 == value ) => if (finalStartDate ==null)
{
finalStartDate=DateTime.parse(previousRecord(3).toString,DateTimeFormat.forPattern(dateFormat))
finalEndDate=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
if(previousRecordEndTime < currentRecordEndTime)
finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,timeGenerator(finalStartDate),timeGenerator(finalEndDate))
if(previousRecordEndTime > currentRecordEndTime)
{
finalEndDate=DateTime.parse(previousRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,timeGenerator(finalStartDate),timeGenerator(finalEndDate))
}
}
else
{
if(previousRecordEndTime > currentRecordEndTime)
finalEndDate=DateTime.parse(previousRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
if(previousRecordEndTime < currentRecordEndTime)
finalEndDate=DateTime.parse(currentRecord(4).toString,DateTimeFormat.forPattern(dateFormat))
finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,timeGenerator(finalStartDate),timeGenerator(finalEndDate)) 
}
case _ => {finalArrayBuffer+=program(currentRecord(0).toString,currentRecord(1).toString,currentRecord(2).toString,currentRecord(3).toString,currentRecord(4).toString)//;finalArrayBuffer+=program(previousRecord(0).toString,previousRecord(1).toString,previousRecord(2).toString,previousRecord(3).toString,previousRecord(4).toString)
}
}
}
}
}
}
}
}


def timeGenerator(dateTime:org.joda.time.DateTime)=s"${hourMinuteSecondCorrector(dateTime.getHourOfDay)}:${hourMinuteSecondCorrector(dateTime.getMinuteOfHour)}:${hourMinuteSecondCorrector(dateTime.getSecondOfMinute)}"

def hourMinuteSecondCorrector(number:Int)=
{
val numberString=number.toString
var outPutNumberString=""
numberString.length match {
case 1 => outPutNumberString=s"0${numberString}"
case _ => outPutNumberString=s"${numberString}"
}
outPutNumberString
}



//Q3:
//----



import org.joda.time.DateTime
import org.joda.time.format.DateTimeFormat
/*
input
mm/dd/yyyy
yyyy/mm/dd

output
yyyy-MM-dd
*/

def dateGenerator(dateTime:org.joda.time.DateTime)=s"${dateTime.getYear}-${dayMonthCorrector(dateTime.getMonthOfYear)}-${dayMonthCorrector(dateTime.getDayOfMonth)}"

def dayMonthCorrector(number:Int)=
{
val numberString=number.toString
var outPutNumberString=""
numberString.length match {
case 1 => outPutNumberString=s"0${numberString}"
case _ => outPutNumberString=s"${numberString}"
}
outPutNumberString
}

val monthFirst="mm/dd/yyyy"
val yearFirst="yyyy/mm/dd"
//val outPut="yyyy-MM-dd"
val input="10/22/2019"
val checkNumber=input.indexOf("/")
//val dateFormat=new Date("10/22/2019")
var outputString=""
checkNumber match {
case value if value== 2 =>{ val dateTemp=DateTime.parse(input,DateTimeFormat.forPattern(monthFirst)); outputString=dateGenerator(dateTemp)}
case value if value== 4 =>{ val dateTemp=DateTime.parse(input,DateTimeFormat.forPattern(yearFirst)); outputString=dateGenerator(dateTemp)}
case _ => println("incorrect format")
}

println(outputString)






