package org.constants

object projectConstants {
  val delimiterArgConstant="delimiter"
  val inferSchemaArgConstant="inferSchema"
  val outputModeArg="outputMode"
  val csvFormat="com.databricks.spark.csv"
  val kafkaFormat="kafka"
  val kafkaSSLFormat="kafkaSSL"
  val kafkaTopicArg="topic"
  val kafkaBootStrapServersArg="kafka.bootstrap.servers"
  val kafkaValueDeserializerArg="value.deserializer"
  val kafkaKeyDeserializerArg="key.deserializer"
  val kafkaValueSerializerArg="value.serializer"
  val kafkaKeySerializerArg="key.serializer"
  val deltaReplaceWhereClause="replaceWhere"
  val deltaMergeSchemaClause="mergeSchema"
  val deltaOverWriteSchemaClause="overwriteSchema"
  val checkPointLocationArg="checkpointLocation"
  val pathArg="path"
  val startingOffsetsArg="startingOffsets"
  val subscribeArg="subscribe"
  val deltaFormat="delta"
  val consoleFormat="console"
  val rddPartitionArg="rddPartitionArg"
  val fileTypeDeltaValue="delta"
  val fileFormatArg="format"
  val columnNameArg="columnNames"
  val columnNameSepArg="columnNameSeparator"
  val fileTypeArgConstant="fileType"
  val fileTypeParquetValue="parquet"
  val fileTypeAvroValue="avro"
  val fileTypeOrcValue="orc"
  val fileTypeJsonValue="json"
  val pathSep="/"
  val fileTypeXmlValue="xml"
  val fileRootTagXmlArg ="rootTag"
  val fileRowTagXmlArg ="rowTag"
  val hbaseFormat="org.apache.spark.sql.execution.datasources.hbase"
  val kafkaStringDeserializer="org.apache.kafka.common.serialization.StringDeserializer"
  val kafkaStringSerializer="org.apache.kafka.common.serialization.StringSerializer"
  val kafkaSSLTrustStoreLocationArg="kafkaSSLTrustStoreLocationArg"
  val kafkaSSLTrustStoreLocation="kafka.ssl.truststore.location"
  val kafkaSSLTrustStorePasswordArg="kafkaSSLTrustStorePasswordArg"
  val kafkaSSLTrustStorePassword="kafka.ssl.truststore.password"
  val kafkaSSLKeyStoreLocationArg="kafkaSSLKeyStoreLocationArg"
  val kafkaSSLKeyStoreLocation="kafka.ssl.keystore.location"
  val kafkaSSLKeyStorePasswordArg="kafkaSSLKeyStorePasswordArg"
  val kafkaSSLKeyStorePassword="kafka.ssl.keystore.password"
  val kafkaSSLKeyPasswordArg="kafkaSSLKeyPasswordArg"
  val kafkaSSLKeyPassword="kafka.ssl.key.password"
  val kafkaSecurityProtocolArg="kafkaSecurityProtocolArg"
  val kafkaSecurityProtocol="kafka.security.protocol"
  val kafkaSSLTruststoreTypeArg="kafkaSSLTruststoreType"
  val kafkaSSLTruststoreType="kafka.ssl.truststore.type"
  val kafkaSSLEndpointIdentificationAlgorithmArg="kafkaSSLEndpointIdentificationAlgorithmArg"
  val kafkaSSLEndpointIdentificationAlgorithm="kafka.ssl.endpoint.identification.algorithm"

  val fileTypeXmlFormatValue="com.databricks.spark.xml"
  val fileTypeAvroFormatValue="com.databricks.spark.avro"
  val fileTypeJDBCValue="jdbc"
  val fileTypeCsvValue="csvHeader"
  val fileTypeCsvHeaderColumnPassedValue="csvNoHeaderColumnPassed"
  val filePathArgValue="inputPath"
  val headerArgConstant="header"
  val emptyValueArg="emptyValue"
  val fileOverwriteValue="overwrite"
  val fileAppendValue="append"
  val fileOverwriteAppendArg="fileOverwriteAppendArg"
  val driverOption="driver"
  val userOption="user"
  val passwordOption="password"
  val urlOption="url"
  val dbtableOption="dbtable"
  val dbtableReadOption="dbtableRead"
  val dbtableWriteOption="dbtableWrite"

  val delimiterOr="|"
  val delimiterNot="!"
  val delimiterComma=","
  val delimiterTilde="~"
  val booleanTrue=true
  val booleanFalse=false
  val stringTrue="true"
  val stringFalse="false"
  val basePathArgConstant="basePath"
  val basePathValueConstant="basePath"
  def trueFalseFinder(value:String)=    value  match {case value if value==stringTrue => projectConstants.booleanTrue ; case value  if value== stringFalse  => projectConstants.booleanFalse ; case _ => projectConstants.booleanFalse }
}

